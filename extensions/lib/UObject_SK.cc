
// Метод с использованием заказа датчиков
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
/*
 DO NOT EDIT THIS FILE. IT IS AUTOGENERATED FILE.
 ALL YOUR CHANGES WILL BE LOST.
 
 НЕ РЕДАКТИРУЙТЕ ЭТОТ ФАЙЛ. ЭТОТ ФАЙЛ СОЗДАН АВТОМАТИЧЕСКИ.
 ВСЕ ВАШИ ИЗМЕНЕНИЯ БУДУТ ПОТЕРЯНЫ.
*/ 
// --------------------------------------------------------------------------
// generate timestamp: 2024-01-03+03:00
// -----------------------------------------------------------------------------
#include <memory>
#include <iomanip>
#include "Configuration.h"
#include "Exceptions.h"
#include "LogServer.h"
#include "DebugStream.h"
#include "LogAgregator.h"
#include "UObject_SK.h"

// -----------------------------------------------------------------------------
using namespace std;
using namespace uniset3;
using namespace uniset3::umessage;
// -----------------------------------------------------------------------------

// --------------------------------------------------------------------------

// -----------------------------------------------------------------------------
UObject_SK::UObject_SK():
// Инициализация идентификаторов (имена берутся из конф. файла)

// Используемые идентификаторы сообщений (имена берутся из конф. файла)

// variables (public and proteced)

// ------------------
active(false),

idHeartBeat(DefaultObjectId),
maxHeartBeat(10),
confnode(0),
smReadyTimeout(0),
activated(false),
askPause(2000),
forceOut(false),
// private variables

end_private(false)
{
    mycrit << "UObject: init failed!!!!!!!!!!!!!!!" << endl;
    throw uniset3::Exception( std::string(myname+": init failed!!!") );
}
// -----------------------------------------------------------------------------
// ( val, confval, globalval, default val )
static const std::string init4_str( const std::string& s1, const std::string& s2,
                    const std::string& s3, const std::string& s4 )
{
    if( !s1.empty() )
        return s1;
    if( !s2.empty() )
        return s2;

    if( !s3.empty() )
        return s3;
    
    return s4;
}
// -----------------------------------------------------------------------------
// ( val, confval, default val )
static const std::string init3_str( const std::string& s1, const std::string& s2, const std::string& s3 )
{
    if( !s1.empty() )
        return s1;
    if( !s2.empty() )
        return s2;
    
    return s3;
}
// -----------------------------------------------------------------------------
static uniset3::ObjectId init_node( xmlNode* cnode, const std::string& prop )
{
    if( prop.empty() )
        return uniset_conf()->getLocalNode();
    
    auto conf = uniset_conf();
    
    if( conf->getProp(cnode,prop).empty() )
        return conf->getLocalNode();

    return conf->getNodeID(conf->getProp(cnode,prop));
}
// -----------------------------------------------------------------------------
UObject_SK::UObject_SK( ObjectId id, xmlNode* cnode, const std::string& _argprefix, xmlNode* globalnode ):
UniSetObject(id),
// Инициализация идентификаторов (имена берутся из конф. файла)

// Используемые идентификаторы сообщений (имена берутся из конф. файла)

// variables

sleep_msec(150),
active(true),
argprefix( (_argprefix.empty() ? myname+"-" : _argprefix) ),

idHeartBeat(DefaultObjectId),
maxHeartBeat(10),
confnode(cnode),
smReadyTimeout(0),
activated(false),
askPause(uniset_conf()->getPIntProp(cnode,"askPause",2000)),
forceOut(false),

end_private(false)
{
    auto conf = uniset_conf();
    
    
    if( uniset3::findArgParam("--print-id-list",uniset_conf()->getArgc(),uniset_conf()->getArgv()) != -1 )
    {

//        abort();
    }


    if( getId() == DefaultObjectId )
    {
        ostringstream err;
        err << "(UObject::init): Unknown ObjectID!";
        throw uniset3::SystemError( err.str() );
    }

    mylog = make_shared<DebugStream>();
    mylog->setLogName(myname);
    {
        ostringstream s;
        s << argprefix << "log";
        conf->initLogStream(mylog,s.str());
    }

    loga = make_shared<LogAgregator>(myname+"-loga");
    loga->add(mylog);
    loga->add(ulog());

    logserv = make_shared<LogServer>(loga);
    logserv->init( argprefix + "logserver", confnode );



    UniXML::iterator it(cnode);

    // ------- init logserver ---
    if( findArgParam("--" + argprefix + "run-logserver", conf->getArgc(), conf->getArgv()) != -1 )
    {
        logserv_host = conf->getArg2Param("--" + argprefix + "logserver-host", it.getProp("logserverHost"), "localhost");
        logserv_port = conf->getArgPInt("--" + argprefix + "logserver-port", it.getProp("logserverPort"), getId());
    }
    
    forceOut = conf->getArgPInt("--" + argprefix + "force-out",it.getProp("forceOut"),false);

    string heart = conf->getArgParam("--" + argprefix + "heartbeat-id",it.getProp("heartbeat_id"));
    if( !heart.empty() )
    {
        idHeartBeat = conf->getSensorID(heart);
        if( idHeartBeat == DefaultObjectId )
        {
            ostringstream err;
            err << myname << ": не найден идентификатор для датчика 'HeartBeat' " << heart;
            throw uniset3::SystemError(err.str());
        }

        int heartbeatTime = conf->getArgPInt("--" + argprefix + "heartbeat-time",it.getProp("heartbeatTime"),conf->getHeartBeatTime());
        if( heartbeatTime>0 )
            ptHeartBeat.setTiming(heartbeatTime);
        else
            ptHeartBeat.setTiming(UniSetTimer::WaitUpTime);

        maxHeartBeat = conf->getArgPInt("--" + argprefix + "heartbeat-max",it.getProp("heartbeat_max"), 10);
    }

    // Инициализация значений
    

    si.set_id(uniset3::DefaultObjectId);
    si.set_node(conf->getLocalNode());
    smTestID = conf->getSensorID(init4_str(conf->getArgParam("--" + argprefix + "sm-test-sid"),conf->getProp(cnode,"smTestSID"),conf->getProp(globalnode,"smTestSID"),""));
    

    sleep_msec = conf->getArgPInt("--" + argprefix + "sleep-msec","150", 150);

    string s_resetTime("");
    if( s_resetTime.empty() ) // -V547
        s_resetTime = "500";

    resetMsgTime = uni_atoi(init4_str(conf->getArgParam("--" + argprefix + "resetMsgTime"),conf->getProp(cnode,"resetMsgTime"),conf->getProp(globalnode,"resetMsgTime"), s_resetTime));
    ptResetMsg.setTiming(resetMsgTime);

    int sm_tout = conf->getArgInt("--" + argprefix + "sm-ready-timeout","");
    if( sm_tout == 0 )
        smReadyTimeout = conf->getNCReadyTimeout();
    else if( sm_tout < 0 )
        smReadyTimeout = UniSetTimer::WaitUpTime;
    else
        smReadyTimeout = sm_tout;

    smTestID = conf->getSensorID(init4_str(conf->getArgParam("--" + argprefix + "sm-test-id"),conf->getProp(cnode,"smTestID"),conf->getProp(globalnode,"smTestID"),""));
    

    if( smTestID == DefaultObjectId ) // -V547
        smTestID = getSMTestID();

    activateTimeout    = conf->getArgPInt("--" + argprefix + "activate-timeout", 120000);

    int msec = conf->getArgPInt("--" + argprefix + "startup-timeout", conf->getStartupIgnoreTimeout());
    ptStartUpTimeout.setTiming(msec);

    // ===================== <variables> =====================
    
    // ===================== end of <variables> =====================

    vmonit(sleep_msec);
    vmonit(resetMsgTime);
    vmonit(forceOut);
    vmonit(argprefix);
    vmonit(idHeartBeat);
    vmonit(maxHeartBeat);
    vmonit(activateTimeout);
    vmonit(smReadyTimeout);
    vmonit(smTestID);

    // help надо выводить в конце, когда уже все переменные инициализированы по умолчанию
    if( uniset3::findArgParam("--" + argprefix + "help",uniset_conf()->getArgc(),uniset_conf()->getArgv()) != -1 )
        cout << help() << endl;
}

// -----------------------------------------------------------------------------

UObject_SK::~UObject_SK()
{
}
// -----------------------------------------------------------------------------
void UObject_SK::updateValues()
{
    // Опрашиваем все входы...
    
}
// -----------------------------------------------------------------------------
void UObject_SK::updatePreviousValues() noexcept
{
    
}
// -----------------------------------------------------------------------------
void UObject_SK::checkSensors()
{
    
}
// -----------------------------------------------------------------------------
bool UObject_SK::setMsg( uniset3::ObjectId _code, bool _state ) noexcept
{
    if( _code == uniset3::DefaultObjectId )
    {
        mylog8 << myname << "(setMsg): попытка послать сообщение с DefaultObjectId" << endl;
        return false;    
    }

    mylog8 << myname << "(setMsg): " << ( _state ? "SEND " : "RESET " ) << endl;

    // взводим автоматический сброс
    if( _state )
    {
        ptResetMsg.reset();
        trResetMsg.hi(false);
    }

    
    
    mylog8 << myname << "(setMsg): not found MessgeOID?!!" << endl;
    return false;
}
// -----------------------------------------------------------------------------
void UObject_SK::resetMsg()
{
    mylog8 << myname << "(resetMsg): reset umessage.." << endl;
// reset umessage

}
// -----------------------------------------------------------------------------
uniset3::ObjectId UObject_SK::getSMTestID() const
{
    if( smTestID != DefaultObjectId )
        return smTestID;

    

    return DefaultObjectId;
}
// -----------------------------------------------------------------------------
void UObject_SK::testMode( bool _state )
{
    if( !_state  )
        return;

    // отключаем все выходы
    
}
// -----------------------------------------------------------------------------
#if 0
Poco::JSON::Object::Ptr UObject_SK::httpDumpIO()
{
    Poco::JSON::Object::Ptr jdata = new Poco::JSON::Object();

    Poco::JSON::Object::Ptr j_in = uniset3::json::make_child(jdata,"in");

    
    
    Poco::JSON::Object::Ptr j_out = uniset3::json::make_child(jdata,"out");

    

    return jdata;
}
// ----------------------------------------------------------------------------
#endif

std::string  UObject_SK::dumpIO()
{
    ostringstream s;
    s << myname << ": " << endl;

    std::list<std::string> v_in;
    ostringstream s1;
    
    
    std::list<std::string> v_out;
    

    s << endl;

    int n = 0;
    for( const auto& e: v_in )
    {
        s << e;
        if( (n++)%2 )
            s << std::endl;
    }
    
    s << endl;
    n = 0;
    for( const auto& e: v_out )
    {
        s << e;
        if( (n++)%2 )
            s << std::endl;
    }
    
    return s.str();
}
// ----------------------------------------------------------------------------
std::string  UObject_SK::msgstr( uniset3::ObjectId id, bool showLinkName ) const
{
    ostringstream s;
        
    return "";
}
// ----------------------------------------------------------------------------
std::string  UObject_SK::str( uniset3::ObjectId id, bool showLinkName ) const
{
    ostringstream s;
        
    return "";
}
// ----------------------------------------------------------------------------
std::string  UObject_SK::strval( uniset3::ObjectId id, bool showLinkName ) const
{
    if( id == DefaultObjectId )
        return "";

    ostringstream s;
        
    return "";
}
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------
void UObject_SK::init_dlog( std::shared_ptr<DebugStream> d ) noexcept
{
    UObject_SK::mylog = d;
}
// ------------------------------------------------------------------------------------------
void UObject_SK::processingMessage( const uniset3::umessage::TransportMessage* _msg )
{
    try
    {
        if( _msg->data().Is<umessage::SensorMessage>() )
        {
             
             msgTypeStat["SensorMessage"] += 1;
             
             uniset3::umessage::SensorMessage sm;
             if( !_msg->data().UnpackTo(&sm) )
             {
                 mycrit  << myname << "(processingMessage): SensorInfo: parse error" << endl;
                 return;
             }

             
             smStat[sm.id()] += 1;
             
             preSensorInfo(&sm);
             return;
        }

        if( _msg->data().Is<umessage::TimerMessage>() )
        {
             
             msgTypeStat["TimerMessage"] += 1;
             
             uniset3::umessage::TimerMessage tm;
             if( !_msg->data().UnpackTo(&tm) )
             {
                 mycrit  << myname << "(processingMessage): TimerInfo: parse error" << endl;
                 return;
            }

            preTimerInfo(&tm);
            return;
        }

        if( _msg->data().Is<umessage::SystemMessage>() )
        {
            
            msgTypeStat["SystemMessage"] += 1;
            
            uniset3::umessage::SystemMessage m;
            if( !_msg->data().UnpackTo(&m) )
            {
                mycrit  << myname << "(processingMessage): SysCommand: parse error" << endl;
                return;
            }

            preSysCommand(&m);
            return;
        }

            UniSetObject::processingMessage(_msg);
    }
    catch( const std::exception& ex )
    {
        
        processingMessageCatchCount++;
        
        mycrit  << myname << "(processingMessage): " << ex.what() << endl;
    }
}
// -----------------------------------------------------------------------------
void UObject_SK::preSysCommand( const uniset3::umessage::SystemMessage* _sm )
{
    switch( _sm->cmd() )
    {
        case uniset3::umessage::SystemMessage::WatchDog:
            myinfo << myname << "(preSysCommand): WatchDog" << endl;
            if( !active || !ptStartUpTimeout.checkTime() )
            {
                mywarn << myname << "(preSysCommand): игнорируем WatchDog, потому-что только-что стартанули" << endl;
                break;
            }
        case uniset3::umessage::SystemMessage::StartUp:
        {
            ostate = "StartUp...";
            try
            {
                if( !logserv_host.empty() && logserv_port != 0 && !logserv->isRunning() )
                {
                    ostate = "StartUp: run log server...";
                    myinfo << myname << "(preSysCommand): run log server " << logserv_host << ":" << logserv_port << endl;
                    logserv->async_run(logserv_host, logserv_port);
                }
            }
            catch( std::exception& ex )
            {
                mywarn << myname << "(preSysCommand): CAN`t run log server err: " << ex.what() << endl;
            }
            catch( ... )
            {
                mywarn << myname << "(preSysCommand): CAN`t run log server err: catch ..." << endl;
            }

            ostate = "StartUp: wait sm ready..";
            if( !waitSM(smReadyTimeout) )
            {
                if( !canceled )
                    uterminate();
                return;
            }

            ptStartUpTimeout.reset();
            // т.к. для io-переменных важно соблюдать последовательность!
            // сперва обновить входы..
            ostate = "StartUp: update values..";
            updateValues();
            ostate = "StartUp: init from SM..";
            initFromSM(); // потом обновить значения переменных, помеченных как инициализируемые из SM
            ostate = "StartUp: update outputs..";
            updateOutputs(true); // а потом уже выходы (принудительное обновление)
            ostate = "StartUp: pre ask sensors..";
            preAskSensors(uniset3::UIONotify);
            ostate = "StartUp: ask sensors..";
            askSensors(uniset3::UIONotify);
            active = true;
            ostate = "StartUp: [OK]";
            break;
        }

        case uniset3::umessage::SystemMessage::FoldUp:
        case uniset3::umessage::SystemMessage::Finish:
            preAskSensors(uniset3::UIODontNotify);
            askSensors(uniset3::UIODontNotify);
            break;

        case uniset3::umessage::SystemMessage::LogRotate:
        {
            // переоткрываем логи
            mylogany << myname << "(preSysCommand): logRotate" << endl;
            string fname( log()->getLogFile() );
            if( !fname.empty() )
            {
            
                mylog->logFile(fname.c_str(),false);
            
                mylogany << myname << "(preSysCommand): ***************** mylog LOG ROTATE *****************" << endl;
            }

            if( logserv && !logserv_host.empty() && logserv_port != 0 )
            {
                try
                {
                    mylogany << myname << "(preSysCommand): try restart logserver.." << endl;
                    logserv->check(true);
                }
                catch( std::exception& ex )
                {
                    mywarn << myname << "(preSysCommand): CAN`t restart log server err: " << ex.what() << endl;
                }
                catch( ... )
                {
                    mywarn << myname << "(preSysCommand): CAN`t restart log server err: catch ..." << endl;
                }
            }
        }
        break;

        default:
            break;
    }

    sysCommand(_sm);
}
// -----------------------------------------------------------------------------
::grpc::Status UObject_SK::metrics(::grpc::ServerContext* context, const ::uniset3::metrics::MetricsParams* request, ::uniset3::metrics::Metrics* response)
{
    auto status = UniSetObject::metrics(context, request, response);
    if( !status.ok() )
        return status;

    *response->add_metrics() = createMetric("processState", ostate);
    if( logserv )
        *response->add_metrics() = createMetric("logServerState", ( logserv->isRunning() ? string("RUNNIG") : string("STOPPED") ));
    else
        *response->add_metrics() = createMetric("logServerState", "NONE");

    *response->add_metrics() = createMetric("processingMessageCatchCount", processingMessageCatchCount);
    for( const auto& s: msgTypeStat )
        *response->add_metrics() = createMetric(s.first, s.second);

    auto timers = getTimersList();
    *response->add_metrics() = createMetric("timerCount", timers.size());
    for( const auto& t: timers )
    {
        auto m = response->add_metrics();
        *m = createMetric("timerTick", ( t.curTick>=0 ? t.curTick : -1 ));
        (*m->mutable_labels())["timerName"] = getTimerName(t.id);
        (*m->mutable_labels())["timerId"] = to_string(t.id);
        (*m->mutable_labels())["timerInterval_msec"] = to_string(t.tmr.getInterval());

        m = response->add_metrics();
        *m = createMetric("timerLeft_msec", t.curTimeMS);
        (*m->mutable_labels())["timerName"] = getTimerName(t.id);
        (*m->mutable_labels())["timerId"] = to_string(t.id);
        (*m->mutable_labels())["timerInterval_msec"] = to_string(t.tmr.getInterval());
    }

    auto vlist = vmon.getList();
    for( const auto& v: vlist )
        *response->add_metrics() = createMetric(v.first, v.second);
    
    return status;
}
// -----------------------------------------------------------------------------
grpc::Status UObject_SK::getInfo(::grpc::ServerContext* context, const ::uniset3::GetInfoParams* request, ::google::protobuf::StringValue* response)
{
    google::protobuf::StringValue binfo;
    auto status = UniSetObject::getInfo(context, request, &binfo);

    if( !status.ok() )
        return status;

    ostringstream inf;

    inf << binfo.value() << endl;
    inf << "process state: " << ostate << endl;

    if( logserv /* && userparam < 0 */ )
    {
        inf << "LogServer: " << logserv_host << ":" << logserv_port 
            << ( logserv->isRunning() ? "   [RUNNIG]" : "   [STOPPED]" ) << endl;

        inf << "         " << logserv->getShortInfo() << endl;
    }
    else
        inf << "LogServer: NONE" << endl;

    
    
    inf << "statistics: " << endl
        << "  processingMessageCatchCount: " << processingMessageCatchCount << endl;
    inf << "  Type of umessage: " << endl;
    for( const auto& s: msgTypeStat )
        inf << "    (" << setw(10) << s.first << "):" << setw(5) << s.second << endl;
    inf << endl;
    

    inf << dumpIO() << endl;
    inf << endl;
    auto timers = getTimersList();
    inf << "Timers[" << timers.size() << "]:" << endl;
    for( const auto& t: timers )
    {
        inf << "  " << setw(15) << getTimerName(t.id) << "[" << t.id  << "]: msec="
            << setw(6) << t.tmr.getInterval()
            << "    timeleft="  << setw(6) << t.curTimeMS
            << "    tick="  << setw(3) << ( t.curTick>=0 ? t.curTick : -1 )
            << endl;
    }
    inf << endl;
    inf << vmon.pretty_str() << endl;
    inf << endl;
    inf << getMonitInfo() << endl;

    response->set_value(inf.str());
    return grpc::Status::OK;
}
// -----------------------------------------------------------------------------
::grpc::Status UObject_SK::setParams(::grpc::ServerContext* context, const ::uniset3::configurator::Params* request, ::uniset3::configurator::Params* response)
{
   auto status = setParams(context, request, response);
    if( !status.ok() )
        return status;

    auto m = response->mutable_params();
    for( const auto& p: request->params() )
    {
        if( p.first == "sleep_msec" )
        {
            (*m)[p.first] = p.second;
            sleep_msec = p.second.dvalue();
            continue;
        }

        if( p.first == "resetMsgTime" )
        {
            (*m)[p.first] = p.second;
            resetMsgTime = p.second.dvalue();
            continue;
        }

        if( p.first == "forceOut" )
        {
            (*m)[p.first] = p.second;
            forceOut = p.second.dvalue();
            continue;
        }
        
        
    }
    
    return grpc::Status::OK;
}
// -----------------------------------------------------------------------------
::grpc::Status UObject_SK::getParams(::grpc::ServerContext* context, const ::uniset3::configurator::Params* request, ::uniset3::configurator::Params* response)
{
   auto status = getParams(context, request, response);
    if( !status.ok() )
        return status;

    auto m = response->mutable_params();

    if( request->params().empty() )
    {
        (*m)["sleep_msec"] = uniset3::createParamValue(sleep_msec);
        (*m)["resetMsgTime"] = uniset3::createParamValue(resetMsgTime);
        (*m)["forceOut"] = uniset3::createParamValue(forceOut);
        if( logserv )
        {
            (*m)["logServerHost"] = uniset3::createParamValue(logserv_host);
            (*m)["logServerPort"] = uniset3::createParamValue(logserv_port);
        }
        else
        {
            (*m)["logServerHost"] = uniset3::createParamValue("");
            (*m)["logServerPort"] = uniset3::createParamValue(0);
        }
        
        return status;
    }

    for( const auto& p: request->params() )
    {
        if( p.first == "sleep_msec" )
        {
            (*m)["sleep_msec"] = uniset3::createParamValue(sleep_msec);
            continue;
        }

        if( p.first == "resetMsgTime" )
        {
            (*m)["resetMsgTime"] = uniset3::createParamValue(resetMsgTime);
            continue;
        }

        if( p.first == "forceOut" )
        {
            (*m)["forceOut"] = uniset3::createParamValue(forceOut);
            continue;
        }

        
    }
    
    return status;
}
// -----------------------------------------------------------------------------
#if 0
Poco::JSON::Object::Ptr UObject_SK::httpGet( const Poco::URI::QueryParameters& params )
{
    Poco::JSON::Object::Ptr json = UniSetObject::httpGet(params);
    
    Poco::JSON::Object::Ptr jdata = json->getObject(myname);
    if( !jdata )
        jdata = uniset3::json::make_child(json,myname);

    Poco::JSON::Object::Ptr jserv = uniset3::json::make_child(jdata,"LogServer");
    if( logserv )
    {
        jserv->set("host",logserv_host);
        jserv->set("port",logserv_port);
        jserv->set("state",( logserv->isRunning() ? "RUNNIG" : "STOPPED" ));
        jserv->set("info", logserv->httpGetShortInfo());
    }
        
    jdata->set("io", httpDumpIO());
    
    auto timers = getTimersList();
    auto jtm = uniset3::json::make_child(jdata,"Timers");

    jtm->set("count",timers.size());
    for( const auto& t: timers )
    {
        auto jt = uniset3::json::make_child(jtm,to_string(t.id));
        jt->set("id", t.id);
        jt->set("name", getTimerName(t.id));
        jt->set("msec", t.tmr.getInterval());
        jt->set("timeleft", t.curTimeMS);
        jt->set("tick", ( t.curTick>=0 ? t.curTick : -1 ));
    }

    auto vlist = vmon.getList();
    auto jvmon = uniset3::json::make_child(jdata,"Variables");
    
    for( const auto& v: vlist )
        jvmon->set(v.first,v.second);

    
    auto jstat = uniset3::json::make_child(jdata,"Statistics");
    jstat->set("processingMessageCatchCount", processingMessageCatchCount);

    auto jsens = uniset3::json::make_child(jstat,"sensors");
    for( const auto& s: smStat )
    {
        std::string sname(ObjectIndex::getShortName( uniset_conf()->oind->getMapName(s.first)));
        auto js = uniset3::json::make_child(jsens,sname);
        js->set("id", s.first);
        js->set("name", sname);
        js->set("count", s.second);
    }
    
        
    httpGetUserData(jdata);

    return json;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::httpHelp( const Poco::URI::QueryParameters& params )
{
    uniset3::json::help::object myhelp(myname, UniSetObject::httpGet(params));

    // 'log'
    uniset3::json::help::item cmd("log","show log level");
    myhelp.add(cmd);

    return myhelp;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::httpRequest( const std::string& req, const Poco::URI::QueryParameters& p )
{
    if( req == "log" )
        return httpRequestLog(p);
    
    return UniSetObject::httpRequest(req,p);
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::httpRequestLog( const Poco::URI::QueryParameters& p )
{
    Poco::JSON::Object::Ptr jret = new Poco::JSON::Object();
    jret->set("log",Debug::str(mylog->level()));
    return jret;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::request_params_set( const std::string& req, const Poco::URI::QueryParameters& params )
{
    Poco::JSON::Object::Ptr jret = new Poco::JSON::Object();
    Poco::JSON::Array::Ptr jupdated = uniset3::json::make_child_array(jret, "updated");

    for( const auto& p: params )
    {
        if( p.first == "sleep_msec" )
        {
            int val = uni_atoi(p.second);
            if( val > 0 )
            {
                sleep_msec = uni_atoi(p.second);
                jupdated->add(p.first);
            }
            continue;
        }

        if( p.first == "resetMsgTime" )
        {
            int val = uni_atoi(p.second);
            if( val > 0 )
            {
                resetMsgTime = uni_atoi(p.second);
                jupdated->add(p.first);
            }
            continue;
        }

        if( p.first == "forceOut" )
        {
            int val = uni_atoi(p.second);
            if( val > 0 )
            {
                forceOut = uni_atoi(p.second);
                jupdated->add(p.first);
            }
            continue;
        }

        
    }

    jret->set("Result", (jupdated->size() > 0 ? "OK" : "FAIL") );
    return jret;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::request_params_get( const std::string& req, const Poco::URI::QueryParameters& params )
{
    Poco::JSON::Object::Ptr jret = new Poco::JSON::Object();

    if( params.empty() )
    {
       jret->set("sleep_msec",sleep_msec);
       jret->set("resetMsgTime",resetMsgTime);
       jret->set("forceOut",forceOut);
        
        return jret;
    }

    for( const auto& p: params )
    {
        if( p.first == "sleep_msec" )
        {
            jret->set(p.first,sleep_msec);
            continue;
        }

        if( p.first == "resetMsgTime" )
        {
            jret->set(p.first,resetMsgTime);
            continue;
        }

        if( p.first == "forceOut" )
        {
            jret->set(p.first,forceOut);
            continue;
        }

        
    }
    return jret;
}
#endif
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
bool UObject_SK::activateObject()
{
    // блокирование обработки Startup 
    // пока не пройдёт инициализация датчиков
    // см. preSysCommand()
    {
        activated = false;
        UniSetObject::activateObject();
        activated = true;
    }

    return true;
}
// -----------------------------------------------------------------------------
bool UObject_SK::deactivateObject()
{
    canceled = true;
    return UniSetObject::deactivateObject();
}
// -----------------------------------------------------------------------------
void UObject_SK::preTimerInfo( const uniset3::umessage::TimerMessage* _tm )
{
    timerInfo(_tm);
}
// ----------------------------------------------------------------------------
bool UObject_SK::waitSM( int wait_msec, ObjectId _testID )
{


    if( _testID == DefaultObjectId )
        _testID = smTestID;

    if( _testID == DefaultObjectId )
        return true;

    myinfo << myname << "(waitSM): waiting SM ready "
            << wait_msec << " msec"
            << " testID=" << _testID << endl;

    // waitReady можно использовать т.к. датчик это по сути IONotifyController
    if( !ui->waitReadyWithCancellation(_testID,wait_msec,canceled) )
    {
        ostringstream err;
        err << myname 
            << "(waitSM): Не дождались готовности(exists) SharedMemory к работе в течение " 
            << wait_msec << " мсек";
        mycrit << err.str() << endl;
        return false;
    }

    if( !ui->waitWorking(_testID,wait_msec) )
    {
        ostringstream err;
        err << myname
            << "(waitSM): Не дождались готовности(work) SharedMemory к работе в течение "
            << wait_msec << " мсек";

        mycrit << err.str() << endl;
        return false;
    }

    return true;
}
// ----------------------------------------------------------------------------
std::string UObject_SK::help() const noexcept
{
    ostringstream s;
    s << " ************* " << myname << " HELP:" << " ************* " << endl;
    s <<  "Init default values: "  << endl;

    s << endl;
    
    s <<  "--"  <<  argprefix  <<  "sm-ready-timeout msec   - wait SM ready for ask sensors. Now: "  << smReadyTimeout << endl;
    s <<  "--"  <<  argprefix  <<  "sm-test-id msec sensor  - sensor for test SM ready. Now: "  << smTestID << endl;
    s <<  "--"  <<  argprefix  <<  "sleep-msec msec         - step period. Now: "  << sleep_msec << endl;
    
    s <<  "--"  <<  argprefix  <<  "activate-timeout msec   - activate process timeout. Now: "  << activateTimeout << endl;
    s <<  "--"  <<  argprefix  <<  "startup-timeout msec    - wait startup timeout. Now: "  << ptStartUpTimeout.getInterval() << endl;
    s <<  "--"  <<  argprefix  <<  "force-out [0|1]         - 1 - save out-values in SM at each step. Now: " << forceOut  << endl;
    s <<  "--"  <<  argprefix  <<  "heartbeat-max num       - max value for heartbeat counter. Now: " <<  maxHeartBeat << endl;
    s <<  "--"  <<  argprefix  <<  "heartbeat-time msec     - heartbeat periond. Now: " << ptHeartBeat.getInterval() << endl;
    s << endl;
    s << "--print-id-list - print ID list" << endl;
    s << endl;
    s << " ****************************************************************************************** " << endl;
    
    
    return s.str();
}
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------
void UObject_SK::callback() noexcept
{
    if( !active )
        return;
    try
    {

        // проверка таймеров
        checkTimers(this);

        if( resetMsgTime>0 && trResetMsg.hi(ptResetMsg.checkTime()) )
        {
//            cout << myname <<  ": ********* reset umessage *********" << endl;
            resetMsg();
        }

        // обработка сообщений (таймеров и т.п.)
        for( unsigned int i=0; i<20; i++ )
        {
            auto m = receiveMessage();
            if( !m )
                break;
            processingMessage(m.get());

            updateOutputs(forceOut);
//            updatePreviousValues();
        }

        // Выполнение шага программы
        step();

        // "сердцебиение"
        if( idHeartBeat!=DefaultObjectId && ptHeartBeat.checkTime() )
        {
            try
            {
                ui->setValue(idHeartBeat,maxHeartBeat);
                ptHeartBeat.reset();
            }
            catch( const uniset3::Exception& ex )
            {
                mycrit << myname << "(execute): " << ex << endl;
            }
        }

        // обновление выходов
        updateOutputs(forceOut);
        updatePreviousValues();
    }
    catch( const std::exception& ex )
    {
        mycrit << myname << "(execute): catch " << ex.what()  <<   endl;
    }

    if( !active )
        return;
    
    msleep( sleep_msec );
}
// -----------------------------------------------------------------------------
void UObject_SK::setValue( uniset3::ObjectId _sid, long _val )
{
    if( _sid == uniset3::DefaultObjectId )
        return;
        
    

    ui->setValue(_sid,_val);
}
// -----------------------------------------------------------------------------
void UObject_SK::updateOutputs( bool _force )
{
    
}
// -----------------------------------------------------------------------------
void UObject_SK::preSensorInfo( const uniset3::umessage::SensorMessage* _sm )
{
    
    
    sensorInfo(_sm);
}
// -----------------------------------------------------------------------------
void UObject_SK::initFromSM()
{
    
}
// -----------------------------------------------------------------------------
void UObject_SK::askSensor( uniset3::ObjectId _sid, uniset3::UIOCommand _cmd, uniset3::ObjectId _node )
{
    ui->askRemoteSensor(_sid,_cmd,_node,getId());
}
// -----------------------------------------------------------------------------
long UObject_SK::getValue( uniset3::ObjectId _sid )
{
    try
    {


        return ui->getValue(_sid);
    }
    catch( const uniset3::Exception& ex )
    {
        mycrit << myname << "(getValue): " << ex << endl;
        throw;
    }
}
// -----------------------------------------------------------------------------

void UObject_SK::preAskSensors( uniset3::UIOCommand _cmd )
{
    PassiveTimer ptAct(activateTimeout);
    while( !activated && !ptAct.checkTime() )
    {    
        cout << myname << "(preAskSensors): wait activate..." << endl;
        msleep(300);
        if( activated )
            break;
    }
            
    if( !activated )
        mycrit << myname
            << "(preAskSensors): ************* don`t activated?! ************" << endl;

    while( !canceled )
    {
        try
        {
        
            return;
        }
        catch( const uniset3::Exception& ex )
        {
            mycrit << myname << "(preAskSensors): " << ex << endl;
        }
        catch( const std::exception&ex )
        {
        mycrit << myname << "(execute): catch " << ex.what()  <<   endl;
        }

        msleep(askPause);
    }
}
// -----------------------------------------------------------------------------
